/// Pong Game for Sega Genesis/Megadrive (Rust Version)
///
/// A simple Pong implementation in Rust demonstrating:
/// - Raw pointer access for hardware I/O
/// - Struct definitions and methods
/// - Game loop with input handling
///
/// NOTE: This is a reference implementation. The Rust frontend may require
/// additional features to compile this completely. See pong.c for the
/// fully functional C version.
///
/// Compile: smdc pong.genesis-rs -o pong.bin -t rom --domestic-name "PONG" --overseas-name "PONG"

#![no_std]
#![no_main]

// ============================================================================
// Hardware Registers (Memory-mapped I/O)
// ============================================================================

/// VDP Data port address
const VDP_DATA: *mut u16 = 0xC00000 as *mut u16;
/// VDP Control port address
const VDP_CTRL: *mut u16 = 0xC00004 as *mut u16;
/// Controller data port
const CTRL_DATA: *const u8 = 0xA10003 as *const u8;
/// Controller control port
const CTRL_CTRL: *mut u8 = 0xA10009 as *mut u8;

// ============================================================================
// Constants
// ============================================================================

const SCREEN_WIDTH: i32 = 320;
const SCREEN_HEIGHT: i32 = 224;

const PADDLE_WIDTH: i32 = 8;
const PADDLE_HEIGHT: i32 = 32;
const PADDLE_SPEED: i32 = 4;

const BALL_SIZE: i32 = 8;
const BALL_SPEED: i32 = 3;

const LEFT_MARGIN: i32 = 16;
const RIGHT_MARGIN: i32 = 304;
const TOP_MARGIN: i32 = 8;
const BOTTOM_MARGIN: i32 = 216;

// ============================================================================
// Game State Structures
// ============================================================================

/// Paddle state
struct Paddle {
    x: i32,
    y: i32,
    score: i32,
}

/// Ball state
struct Ball {
    x: i32,
    y: i32,
    dx: i32,
    dy: i32,
}

// ============================================================================
// Global State
// ============================================================================

static mut PLAYER1: Paddle = Paddle { x: 24, y: 96, score: 0 };
static mut PLAYER2: Paddle = Paddle { x: 288, y: 96, score: 0 };
static mut BALL: Ball = Ball { x: 156, y: 108, dx: 3, dy: 2 };
static mut FRAME_COUNT: i32 = 0;

// ============================================================================
// VDP Functions
// ============================================================================

/// Write a value to a VDP register
fn vdp_set_register(reg: i32, value: i32) {
    unsafe {
        let cmd = 0x8000 | ((reg << 8) & 0xFF00) | (value & 0xFF);
        *VDP_CTRL = cmd as u16;
    }
}

/// Initialize the VDP for basic operation
fn vdp_init() {
    vdp_set_register(0, 0x04);   // Mode register 1: No H interrupt
    vdp_set_register(1, 0x44);   // Mode register 2: Enable display, V interrupt
    vdp_set_register(2, 0x30);   // Plane A name table at 0xC000
    vdp_set_register(3, 0x00);   // Window name table
    vdp_set_register(4, 0x07);   // Plane B name table at 0xE000
    vdp_set_register(5, 0x78);   // Sprite table at 0xF000
    vdp_set_register(6, 0x00);   // Unused
    vdp_set_register(7, 0x00);   // Background color: palette 0, color 0
    vdp_set_register(10, 0xFF);  // H interrupt counter
    vdp_set_register(11, 0x00);  // Mode register 3
    vdp_set_register(12, 0x81);  // Mode register 4: H40 mode (320 pixels)
    vdp_set_register(13, 0x3F);  // H scroll table at 0xFC00
    vdp_set_register(15, 0x02);  // Auto-increment: 2
    vdp_set_register(16, 0x01);  // Scroll size: 64x32
    vdp_set_register(17, 0x00);  // Window H position
    vdp_set_register(18, 0x00);  // Window V position
}

/// Set VRAM write address
fn vdp_set_write_address(address: i32) {
    unsafe {
        *VDP_CTRL = (0x4000 | (address & 0x3FFF)) as u16;
        *VDP_CTRL = ((address >> 14) & 0x03) as u16;
    }
}

/// Write data to VDP
fn vdp_write_data(data: i32) {
    unsafe {
        *VDP_DATA = data as u16;
    }
}

/// Wait for vertical blank
fn vdp_wait_vblank() {
    unsafe {
        // Wait for VBlank bit (bit 3) to be set
        while (*VDP_CTRL & 0x08) == 0 {
            // Busy wait
        }
    }
}

// ============================================================================
// Palette Setup
// ============================================================================

/// Set up the color palette
fn setup_palette() {
    unsafe {
        // Set CRAM write address
        *VDP_CTRL = 0xC000;
        *VDP_CTRL = 0x0000;

        // Color 0: Black (background)
        *VDP_DATA = 0x0000;

        // Color 1: White (paddles, ball)
        *VDP_DATA = 0x0EEE;

        // Color 2: Green (field lines)
        *VDP_DATA = 0x00E0;

        // Color 3: Red (score)
        *VDP_DATA = 0x000E;
    }
}

// ============================================================================
// Sprite Functions
// ============================================================================

/// Update a sprite's position and attributes
fn update_sprite(index: i32, x: i32, y: i32, size: i32, tile: i32) {
    let addr = 0xF000 + (index * 8);
    vdp_set_write_address(addr);

    // Y position (add 128 for screen offset)
    vdp_write_data(y + 128);

    // Size and link to next sprite
    vdp_write_data((size << 8) | (index + 1));

    // Tile attributes
    vdp_write_data(tile);

    // X position (add 128 for screen offset)
    vdp_write_data(x + 128);
}

/// Clear a sprite (make invisible)
fn clear_sprite(index: i32) {
    let addr = 0xF000 + (index * 8);
    vdp_set_write_address(addr);
    vdp_write_data(0);
    vdp_write_data(0);
    vdp_write_data(0);
    vdp_write_data(0);
}

// ============================================================================
// Controller Input
// ============================================================================

/// Read the current controller state
fn read_controller() -> i32 {
    unsafe {
        // Configure controller port
        *CTRL_CTRL = 0x40;

        // Read and return button state
        *CTRL_DATA as i32
    }
}

// ============================================================================
// Game Logic
// ============================================================================

/// Reset the ball to the center of the screen
fn reset_ball() {
    unsafe {
        BALL.x = 156;
        BALL.y = 108;

        // Alternate direction based on frame count
        if (FRAME_COUNT & 1) != 0 {
            BALL.dx = BALL_SPEED;
        } else {
            BALL.dx = -BALL_SPEED;
        }
        BALL.dy = 2;
    }
}

/// Update ball position and handle collisions
fn update_ball() {
    unsafe {
        // Move ball
        BALL.x = BALL.x + BALL.dx;
        BALL.y = BALL.y + BALL.dy;

        // Bounce off top wall
        if BALL.y < TOP_MARGIN {
            BALL.y = TOP_MARGIN;
            BALL.dy = -BALL.dy;
        }

        // Bounce off bottom wall
        if BALL.y > BOTTOM_MARGIN - BALL_SIZE {
            BALL.y = BOTTOM_MARGIN - BALL_SIZE;
            BALL.dy = -BALL.dy;
        }

        // Check collision with player 1 paddle (left)
        if BALL.x < PLAYER1.x + PADDLE_WIDTH {
            if BALL.x > PLAYER1.x - BALL_SIZE {
                if BALL.y + BALL_SIZE > PLAYER1.y {
                    if BALL.y < PLAYER1.y + PADDLE_HEIGHT {
                        // Bounce off paddle
                        BALL.x = PLAYER1.x + PADDLE_WIDTH;
                        BALL.dx = -BALL.dx;

                        // Add spin based on hit position
                        let hit_pos = BALL.y - PLAYER1.y;
                        if hit_pos < 10 {
                            BALL.dy = BALL.dy - 1;
                        }
                        if hit_pos > 22 {
                            BALL.dy = BALL.dy + 1;
                        }
                    }
                }
            }
        }

        // Check collision with player 2 paddle (right)
        if BALL.x + BALL_SIZE > PLAYER2.x {
            if BALL.x < PLAYER2.x + PADDLE_WIDTH {
                if BALL.y + BALL_SIZE > PLAYER2.y {
                    if BALL.y < PLAYER2.y + PADDLE_HEIGHT {
                        // Bounce off paddle
                        BALL.x = PLAYER2.x - BALL_SIZE;
                        BALL.dx = -BALL.dx;

                        // Add spin
                        let hit_pos = BALL.y - PLAYER2.y;
                        if hit_pos < 10 {
                            BALL.dy = BALL.dy - 1;
                        }
                        if hit_pos > 22 {
                            BALL.dy = BALL.dy + 1;
                        }
                    }
                }
            }
        }

        // Check for scoring (ball passed left edge)
        if BALL.x < LEFT_MARGIN {
            PLAYER2.score = PLAYER2.score + 1;
            reset_ball();
        }

        // Check for scoring (ball passed right edge)
        if BALL.x > RIGHT_MARGIN {
            PLAYER1.score = PLAYER1.score + 1;
            reset_ball();
        }

        // Clamp ball velocity
        if BALL.dy > 5 {
            BALL.dy = 5;
        }
        if BALL.dy < -5 {
            BALL.dy = -5;
        }
    }
}

/// Update paddle positions based on input
fn update_paddles(buttons: i32) {
    unsafe {
        // Player 1 controls (Up/Down on controller)
        // Bit 0 = Up, Bit 1 = Down (active low)
        if (buttons & 0x01) == 0 {
            PLAYER1.y = PLAYER1.y - PADDLE_SPEED;
        }
        if (buttons & 0x02) == 0 {
            PLAYER1.y = PLAYER1.y + PADDLE_SPEED;
        }

        // Clamp player 1 position
        if PLAYER1.y < TOP_MARGIN {
            PLAYER1.y = TOP_MARGIN;
        }
        if PLAYER1.y > BOTTOM_MARGIN - PADDLE_HEIGHT {
            PLAYER1.y = BOTTOM_MARGIN - PADDLE_HEIGHT;
        }

        // Simple AI for player 2
        if BALL.x > 160 {
            // Ball is on right side, AI becomes more active
            if PLAYER2.y + 16 < BALL.y {
                PLAYER2.y = PLAYER2.y + 3;
            }
            if PLAYER2.y + 16 > BALL.y {
                PLAYER2.y = PLAYER2.y - 3;
            }
        }

        // Clamp player 2 position
        if PLAYER2.y < TOP_MARGIN {
            PLAYER2.y = TOP_MARGIN;
        }
        if PLAYER2.y > BOTTOM_MARGIN - PADDLE_HEIGHT {
            PLAYER2.y = BOTTOM_MARGIN - PADDLE_HEIGHT;
        }
    }
}

// ============================================================================
// Rendering
// ============================================================================

/// Render all game sprites
fn render() {
    unsafe {
        // Update paddle 1 sprite (sprite 0)
        update_sprite(0, PLAYER1.x, PLAYER1.y, 0x08, 1);

        // Update paddle 2 sprite (sprite 1)
        update_sprite(1, PLAYER2.x, PLAYER2.y, 0x08, 1);

        // Update ball sprite (sprite 2)
        update_sprite(2, BALL.x, BALL.y, 0x00, 2);

        // End sprite list
        clear_sprite(3);
    }
}

/// Check if game is over
fn is_game_over() -> bool {
    unsafe {
        PLAYER1.score >= 10 || PLAYER2.score >= 10
    }
}

// ============================================================================
// Main Entry Point
// ============================================================================

#[no_mangle]
pub fn main() {
    // Initialize hardware
    vdp_init();
    setup_palette();

    // Clear all sprites
    let mut i: i32 = 0;
    while i < 80 {
        clear_sprite(i);
        i = i + 1;
    }

    // Main game loop
    while !is_game_over() {
        // Wait for VBlank to sync with display
        vdp_wait_vblank();

        // Read controller input
        let buttons = read_controller();

        // Update game state
        update_paddles(buttons);
        update_ball();

        // Render sprites
        render();

        // Increment frame counter
        unsafe {
            FRAME_COUNT = FRAME_COUNT + 1;
        }
    }

    // Game over - loop forever
    loop {
        vdp_wait_vblank();
    }
}
